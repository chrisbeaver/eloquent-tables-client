var eloquentTables = (function () {
'use strict';

var tables$1 = document.getElementsByClassName('eloquent-table');

var headers = [].slice.call(tables$1[0].tHead.querySelectorAll('th')).map(function (header) {
    return header.innerHTML;
});

// export let paginator = document.createElement('div');

var total_count = { value: 0,
    set: function set(value) {
        this.value = value;
    }
};

var rows = {
    collection: null,
    set: function set(value) {
        this.collection = value;
    }
};

var config = {
    tableRows: 10,
    setTableRows: function setTableRows(value) {
        this.tableRows = value;
    }
};

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

/**
 * Fired on AJAX response to construct paginated results.
 *
 */


var Paginator = function () {
    function Paginator(elem, total) {
        classCallCheck(this, Paginator);

        this.elem = elem;
        this.total = total;
    }

    createClass(Paginator, [{
        key: 'calcPages',
        value: function calcPages() {
            return this.total / config.tableRows;
        }
    }, {
        key: 'buildHTML',
        value: function buildHTML() {

            var node = document.createElement('div');
            node.className = 'paginator';
            // wrapper.appendChild(node);
            node.innerHTML = total_count.value;
            this.elem.appendChild(node);
        }
    }, {
        key: 'pages',
        get: function get() {
            return this.calcPages();
        }
    }]);
    return Paginator;
}();

var Header = function () {
    function Header(elem) {
        classCallCheck(this, Header);

        this.elem = elem; // HTML Element
        this.columns = this.load();
    }

    createClass(Header, [{
        key: 'load',
        value: function load() {
            return [].slice.call(this.elem.querySelectorAll('th')).map(function (header) {
                return header.innerHTML;
            });
        }
    }]);
    return Header;
}();

/**
 * AJAX Listener to build table with data returned 
 * from server.
 *
 * @param  {Json} payload a server response
 */
function populateTable(payload) {
    // console.log(tables);
    var elem = tables$1[0].getElementsByTagName('tbody')[0];
    payload.data.forEach(function (data) {

        var row = elem.insertRow(-1);
        // Insert new cells (<td> elements) at the 1st and 2nd position of the "new" <tr> element:
        var cell1 = row.insertCell(0);
        var cell2 = row.insertCell(1);
        var cell3 = row.insertCell(2);
        var cell4 = row.insertCell(3);

        // Add some text to the new cells:
        cell1.innerHTML = data.id;
        cell2.innerHTML = data.company.name;
        cell3.innerHTML = data.name;
        cell4.innerHTML = data.price;
    });
    // console.log(paginator);
    total_count.set(payload.count);
    var paginator = new Paginator(elem, total_count.value);
    paginator.buildHTML();
}

/**
 * AJAX Request to server to get Table data.
 */


/**
 * Call back function fired on AJAX result.
 */
function ajaxListener() {
    // console.log(JSON.parse(this.responseText));
    var elem = tables$1[0]; //.getElementsByTagName('tbody')[0];
    // let table = new Table(elem, rows.set(JSON.parse(this.responseText)));
    // table.load();
    rows.set(JSON.parse(this.responseText));
    populateTable(rows.collection);
}

var Table = function () {
    function Table(elem) {
        classCallCheck(this, Table);

        this.table = elem; // HTML Table Element
        this.parent = this.initialize();
        this.header = this._loadHeader();
        console.log(this.header.columns);
    }

    createClass(Table, [{
        key: 'load',
        value: function load() {

            var r = new XMLHttpRequest();
            r.open('POST', this.table.getAttribute('data-target'), true);
            r.setRequestHeader('X-CSRF-TOKEN', '{{ csrf_token() }}');
            r.setRequestHeader('take', '10');
            r.setRequestHeader('skip', '20');
            r.setRequestHeader('search', 'Wiza');
            r.addEventListener('load', ajaxListener);
            r.onreadystatechange = function () {
                if (r.readyState != 4 || r.status != 200) return;
            };
            r.send();
        }
    }, {
        key: 'initialize',
        value: function initialize() {
            // Put wrapper around table.
            var wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            var table = this.table;
            table.parentElement.insertBefore(wrapper, table);
            wrapper.appendChild(table);
            return wrapper;
        }
    }, {
        key: '_loadHeader',
        value: function _loadHeader() {
            return new Header(this.table.tHead);
        }
    }]);
    return Table;
}();

/**
 * Construct basic framework for creating a table.
 */
function initializeTable() {
    var wrapper = document.createElement('div');
    wrapper.className = 'table-wrapper';
    var table = tables$1[0];

    document.body.insertBefore(wrapper, table);
    wrapper.appendChild(table);
}

// import { ajaxRequest } from './modules/ajaxRequest';

initializeTable();
var elem = tables$1[0];
var table = new Table(elem);
table.load();

return tables$1;

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JpcHRzL2dsb2JhbHMuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL3BhZ2luYXRvci5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21vZHVsZXMvaGVhZGVyLmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9wb3B1bGF0ZVRhYmxlLmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9hamF4UmVxdWVzdC5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21vZHVsZXMvdGFibGUuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL2luaXRpYWxpemVUYWJsZS5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGxldCB0YWJsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdlbG9xdWVudC10YWJsZScpO1xuXG5leHBvcnQgbGV0IGhlYWRlcnMgPSBbXS5zbGljZVxuICAgIC5jYWxsKHRhYmxlc1swXS50SGVhZC5xdWVyeVNlbGVjdG9yQWxsKCd0aCcpKVxuICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXIuaW5uZXJIVE1MO1xuICAgIH0pO1xuXG4vLyBleHBvcnQgbGV0IHBhZ2luYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5leHBvcnQgbGV0IHRvdGFsX2NvdW50ID0geyB2YWx1ZTogMCxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuIFx0fVxufTtcblxuZXhwb3J0IGxldCByb3dzID0geyBcblx0Y29sbGVjdGlvbjogbnVsbCxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuY29sbGVjdGlvbiA9IHZhbHVlO1xuXHR9XG59O1xuXG5leHBvcnQgbGV0IGNvbmZpZyA9IHtcbiAgICB0YWJsZVJvd3M6IDEwLFxuICAgIHNldFRhYmxlUm93czogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy50YWJsZVJvd3MgPSB2YWx1ZTsgfVxufSIsImltcG9ydCB7IHRvdGFsX2NvdW50LCBjb25maWcgfSBmcm9tICcuLi9nbG9iYWxzJztcbi8qKlxuICogRmlyZWQgb24gQUpBWCByZXNwb25zZSB0byBjb25zdHJ1Y3QgcGFnaW5hdGVkIHJlc3VsdHMuXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQYWdpbmF0b3IoKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKCdDb3VudDogJyArIHRvdGFsX2NvdW50KTtcbn1cblxuZXhwb3J0IGNsYXNzIFBhZ2luYXRvciB7XG4gICAgY29uc3RydWN0b3IoZWxlbSwgdG90YWwpIHtcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgIH1cbiAgXG4gICAgZ2V0IHBhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjUGFnZXMoKTtcbiAgICB9XG5cbiAgICBjYWxjUGFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsIC8gY29uZmlnLnRhYmxlUm93cztcbiAgICB9XG5cbiAgICBidWlsZEhUTUwoKSB7XG4gICAgICAgIFxuICAgICAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBub2RlLmNsYXNzTmFtZSA9ICdwYWdpbmF0b3InO1xuICAgICAgICAvLyB3cmFwcGVyLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IHRvdGFsX2NvdW50LnZhbHVlO1xuICAgICAgICB0aGlzLmVsZW0uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxufSIsImV4cG9ydCBjbGFzcyBIZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW0pIHtcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTsgIC8vIEhUTUwgRWxlbWVudFxuICAgICAgICB0aGlzLmNvbHVtbnMgPSB0aGlzLmxvYWQoKTtcbiAgICB9XG4gIFxuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiBbXS5zbGljZVxuICAgICAgICAgIC5jYWxsKHRoaXMuZWxlbS5xdWVyeVNlbGVjdG9yQWxsKCd0aCcpKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlci5pbm5lckhUTUw7XG4gICAgICAgICAgfSk7XG4gICAgfVxufSIsImltcG9ydCB7IHRhYmxlcywgdG90YWxfY291bnQgfSBmcm9tICcuLi9nbG9iYWxzJztcbmltcG9ydCB7IFBhZ2luYXRvciB9IGZyb20gJy4vcGFnaW5hdG9yJztcbi8qKlxuICogQUpBWCBMaXN0ZW5lciB0byBidWlsZCB0YWJsZSB3aXRoIGRhdGEgcmV0dXJuZWQgXG4gKiBmcm9tIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0gIHtKc29ufSBwYXlsb2FkIGEgc2VydmVyIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3B1bGF0ZVRhYmxlKHBheWxvYWQpXG57XG4gICAgLy8gY29uc29sZS5sb2codGFibGVzKTtcbiAgICBjb25zdCBlbGVtID0gdGFibGVzWzBdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0Ym9keScpWzBdO1xuICAgIHBheWxvYWQuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciByb3cgPSBlbGVtLmluc2VydFJvdygtMSk7XG4gICAgICAgIC8vIEluc2VydCBuZXcgY2VsbHMgKDx0ZD4gZWxlbWVudHMpIGF0IHRoZSAxc3QgYW5kIDJuZCBwb3NpdGlvbiBvZiB0aGUgXCJuZXdcIiA8dHI+IGVsZW1lbnQ6XG4gICAgICAgIHZhciBjZWxsMSA9IHJvdy5pbnNlcnRDZWxsKDApO1xuICAgICAgICB2YXIgY2VsbDIgPSByb3cuaW5zZXJ0Q2VsbCgxKTtcbiAgICAgICAgdmFyIGNlbGwzID0gcm93Lmluc2VydENlbGwoMik7XG4gICAgICAgIHZhciBjZWxsNCA9IHJvdy5pbnNlcnRDZWxsKDMpO1xuXG4gICAgICAgIC8vIEFkZCBzb21lIHRleHQgdG8gdGhlIG5ldyBjZWxsczpcbiAgICAgICAgY2VsbDEuaW5uZXJIVE1MID0gZGF0YS5pZDtcbiAgICAgICAgY2VsbDIuaW5uZXJIVE1MID0gZGF0YS5jb21wYW55Lm5hbWU7XG4gICAgICAgIGNlbGwzLmlubmVySFRNTCA9IGRhdGEubmFtZTtcbiAgICAgICAgY2VsbDQuaW5uZXJIVE1MID0gZGF0YS5wcmljZTtcbiAgICB9KTtcbiAgICAvLyBjb25zb2xlLmxvZyhwYWdpbmF0b3IpO1xuICAgIHRvdGFsX2NvdW50LnNldChwYXlsb2FkLmNvdW50KTtcbiAgICBsZXQgcGFnaW5hdG9yID0gbmV3IFBhZ2luYXRvcihlbGVtLCB0b3RhbF9jb3VudC52YWx1ZSk7XG4gICAgcGFnaW5hdG9yLmJ1aWxkSFRNTCgpO1xufSIsImltcG9ydCB7IHRhYmxlcywgcm93cyB9IGZyb20gJy4uL2dsb2JhbHMnO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IHBvcHVsYXRlVGFibGUgfSBmcm9tICcuL3BvcHVsYXRlVGFibGUnO1xuLyoqXG4gKiBBSkFYIFJlcXVlc3QgdG8gc2VydmVyIHRvIGdldCBUYWJsZSBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWpheFJlcXVlc3QoKVxue1xuICAgIGxldCByID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgXG4gICAgci5vcGVuKCdQT1NUJywgdGFibGVzWzBdLmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSwgdHJ1ZSk7XG4gICAgci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUNTUkYtVE9LRU4nLCAne3sgY3NyZl90b2tlbigpIH19Jyk7XG4gICAgci5zZXRSZXF1ZXN0SGVhZGVyKCd0YWtlJywgJzEwJyk7XG4gICAgci5zZXRSZXF1ZXN0SGVhZGVyKCdza2lwJywgJzIwJyk7XG4gICAgci5zZXRSZXF1ZXN0SGVhZGVyKCdzZWFyY2gnLCAnV2l6YScpO1xuICAgIHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGFqYXhMaXN0ZW5lcik7XG4gICAgci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLnJlYWR5U3RhdGUgIT0gNCB8fCByLnN0YXR1cyAhPSAyMDApIHJldHVybjsgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHIucmVzcG9uc2VUZXh0KTtcbiAgICB9O1xuICAgIHIuc2VuZCgndGFrZT0xJyk7XG59XG5cbi8qKlxuICogQ2FsbCBiYWNrIGZ1bmN0aW9uIGZpcmVkIG9uIEFKQVggcmVzdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWpheExpc3RlbmVyKClcbntcbiAgICAvLyBjb25zb2xlLmxvZyhKU09OLnBhcnNlKHRoaXMucmVzcG9uc2VUZXh0KSk7XG4gICAgbGV0IGVsZW0gPSB0YWJsZXNbMF07IC8vLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0Ym9keScpWzBdO1xuICAgIC8vIGxldCB0YWJsZSA9IG5ldyBUYWJsZShlbGVtLCByb3dzLnNldChKU09OLnBhcnNlKHRoaXMucmVzcG9uc2VUZXh0KSkpO1xuICAgIC8vIHRhYmxlLmxvYWQoKTtcbiAgICByb3dzLnNldChKU09OLnBhcnNlKHRoaXMucmVzcG9uc2VUZXh0KSk7XG4gICAgcG9wdWxhdGVUYWJsZShyb3dzLmNvbGxlY3Rpb24pO1xufSIsImltcG9ydCB7IFBhZ2luYXRvciB9IGZyb20gJy4vcGFnaW5hdG9yJztcbmltcG9ydCB7IEhlYWRlciB9IGZyb20gJy4vaGVhZGVyJztcbmltcG9ydCB7IGFqYXhMaXN0ZW5lciB9IGZyb20gJy4vYWpheFJlcXVlc3QnO1xuXG5leHBvcnQgY2xhc3MgVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW0pIHtcbiAgICAgICAgdGhpcy50YWJsZSA9IGVsZW07ICAvLyBIVE1MIFRhYmxlIEVsZW1lbnRcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSB0aGlzLl9sb2FkSGVhZGVyKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuaGVhZGVyLmNvbHVtbnMpO1xuICAgIH1cbiAgXG4gICAgbG9hZCgpIHtcbiAgICAgICAgXG4gICAgICAgIGxldCByID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHIub3BlbignUE9TVCcsIHRoaXMudGFibGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpLCB0cnVlKTtcbiAgICAgICAgci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUNTUkYtVE9LRU4nLCAne3sgY3NyZl90b2tlbigpIH19Jyk7XG4gICAgICAgIHIuc2V0UmVxdWVzdEhlYWRlcigndGFrZScsICcxMCcpO1xuICAgICAgICByLnNldFJlcXVlc3RIZWFkZXIoJ3NraXAnLCAnMjAnKTtcbiAgICAgICAgci5zZXRSZXF1ZXN0SGVhZGVyKCdzZWFyY2gnLCAnV2l6YScpO1xuICAgICAgICByLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBhamF4TGlzdGVuZXIpO1xuICAgICAgICByLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyLnJlYWR5U3RhdGUgIT0gNCB8fCByLnN0YXR1cyAhPSAyMDApIHJldHVybjsgXG4gICAgICAgIH07XG4gICAgICAgIHIuc2VuZCgpO1xuXG4gICAgfVxuICAgIFxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIC8vIFB1dCB3cmFwcGVyIGFyb3VuZCB0YWJsZS5cbiAgICAgICAgbGV0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSAndGFibGUtd3JhcHBlcic7XG4gICAgICAgIGxldCB0YWJsZSA9IHRoaXMudGFibGU7XG4gICAgICAgIHRhYmxlLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHRhYmxlKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0YWJsZSk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIF9sb2FkSGVhZGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEhlYWRlcih0aGlzLnRhYmxlLnRIZWFkKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgdGFibGVzIH0gZnJvbSAnLi4vZ2xvYmFscyc7XG4vKipcbiAqIENvbnN0cnVjdCBiYXNpYyBmcmFtZXdvcmsgZm9yIGNyZWF0aW5nIGEgdGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplVGFibGUoKVxue1xuICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5jbGFzc05hbWUgPSAndGFibGUtd3JhcHBlcic7XG4gICAgbGV0IHRhYmxlID0gdGFibGVzWzBdO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHRhYmxlKTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRhYmxlKTtcbn0iLCJpbXBvcnQgeyB0YWJsZXMgfSBmcm9tICcuL2dsb2JhbHMnO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL21vZHVsZXMvdGFibGUnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVRhYmxlIH0gZnJvbSAnLi9tb2R1bGVzL2luaXRpYWxpemVUYWJsZSc7XG4vLyBpbXBvcnQgeyBhamF4UmVxdWVzdCB9IGZyb20gJy4vbW9kdWxlcy9hamF4UmVxdWVzdCc7XG5cbmluaXRpYWxpemVUYWJsZSgpO1xubGV0IGVsZW0gPSB0YWJsZXNbMF07XG5sZXQgdGFibGUgPSBuZXcgVGFibGUoZWxlbSk7XG50YWJsZS5sb2FkKCk7XG4vLyBhamF4UmVxdWVzdCgpO1xuZXhwb3J0IGRlZmF1bHQgdGFibGVzO1xuIl0sIm5hbWVzIjpbInRhYmxlcyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImhlYWRlcnMiLCJzbGljZSIsImNhbGwiLCJ0SGVhZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYXAiLCJoZWFkZXIiLCJpbm5lckhUTUwiLCJ0b3RhbF9jb3VudCIsInZhbHVlIiwicm93cyIsImNvbGxlY3Rpb24iLCJjb25maWciLCJ0YWJsZVJvd3MiLCJQYWdpbmF0b3IiLCJlbGVtIiwidG90YWwiLCJub2RlIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwiY2FsY1BhZ2VzIiwiSGVhZGVyIiwiY29sdW1ucyIsImxvYWQiLCJwb3B1bGF0ZVRhYmxlIiwicGF5bG9hZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZGF0YSIsImZvckVhY2giLCJyb3ciLCJpbnNlcnRSb3ciLCJjZWxsMSIsImluc2VydENlbGwiLCJjZWxsMiIsImNlbGwzIiwiY2VsbDQiLCJpZCIsImNvbXBhbnkiLCJuYW1lIiwicHJpY2UiLCJzZXQiLCJjb3VudCIsInBhZ2luYXRvciIsImJ1aWxkSFRNTCIsImFqYXhMaXN0ZW5lciIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsIlRhYmxlIiwidGFibGUiLCJwYXJlbnQiLCJpbml0aWFsaXplIiwiX2xvYWRIZWFkZXIiLCJsb2ciLCJyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwiZ2V0QXR0cmlidXRlIiwic2V0UmVxdWVzdEhlYWRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwic2VuZCIsIndyYXBwZXIiLCJwYXJlbnRFbGVtZW50IiwiaW5zZXJ0QmVmb3JlIiwiaW5pdGlhbGl6ZVRhYmxlIiwiYm9keSJdLCJtYXBwaW5ncyI6Ijs7O0FBQU8sSUFBSUEsV0FBU0MsU0FBU0Msc0JBQVQsQ0FBZ0MsZ0JBQWhDLENBQWI7O0FBRVAsQUFBTyxJQUFJQyxVQUFVLEdBQUdDLEtBQUgsQ0FDaEJDLElBRGdCLENBQ1hMLFNBQU8sQ0FBUCxFQUFVTSxLQUFWLENBQWdCQyxnQkFBaEIsQ0FB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
