var eloquentTables = (function () {
'use strict';

var tables$1 = document.getElementsByClassName('eloquent-table');

var headers = [].slice.call(tables$1[0].tHead.querySelectorAll('th')).map(function (header) {
    return header.innerHTML;
});

var total_count = { value: 0,
    set: function set(value) {
        this.value = value;
    }
};

var rows = {
    collection: null,
    set: function set(value) {
        this.collection = value;
    }
};

var config = {
    tableRows: 10,
    setTableRows: function setTableRows(value) {
        this.tableRows = value;
    }
};

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var Header = function () {
    function Header(elem) {
        classCallCheck(this, Header);

        this.elem = elem; // HTML Element
        this.columns = this.load();
    }

    createClass(Header, [{
        key: 'load',
        value: function load() {
            return [].slice.call(this.elem.querySelectorAll('th')).map(function (header) {
                return header.innerHTML;
            });
        }
    }]);
    return Header;
}();

/**
 * Fired on AJAX response to construct paginated results.
 *
 */


var Paginator = function () {
    function Paginator(elem, total) {
        classCallCheck(this, Paginator);

        this.elem = elem;
        this.total = total;
    }

    createClass(Paginator, [{
        key: 'calcPages',
        value: function calcPages() {
            return this.total / config.tableRows;
        }
    }, {
        key: 'buildHTML',
        value: function buildHTML() {

            var node = document.createElement('div');
            node.className = 'paginator';
            // wrapper.appendChild(node);
            node.innerHTML = total_count.value;
            this.elem.appendChild(node);
        }
    }, {
        key: 'pages',
        get: function get() {
            return this.calcPages();
        }
    }]);
    return Paginator;
}();

/**
 * AJAX Listener to build table with data returned 
 * from server.
 *
 * @param  {Json} payload a server response
 */
function populateTable(payload) {
    // console.log(tables);
    var elem = tables$1[0].getElementsByTagName('tbody')[0];
    payload.data.forEach(function (data) {

        var row = elem.insertRow(-1);
        // Insert new cells (<td> elements) at the 1st and 2nd position of the "new" <tr> element:
        var cell1 = row.insertCell(0);
        var cell2 = row.insertCell(1);
        var cell3 = row.insertCell(2);
        var cell4 = row.insertCell(3);

        // Add some text to the new cells:
        cell1.innerHTML = data.id;
        cell2.innerHTML = data.company.name;
        cell3.innerHTML = data.name;
        cell4.innerHTML = data.price;
    });
    // console.log(paginator);
    total_count.set(payload.count);
    var paginator = new Paginator(elem, total_count.value);
    paginator.buildHTML();
}

/**
 * AJAX Request to server to get Table data.
 */


/**
 * Call back function fired on AJAX result.
 */
function ajaxListener() {
    rows.set(JSON.parse(this.responseText));
    populateTable(rows.collection);
}

// import { Paginator } from './paginator';
var Table = function () {
    function Table(elem) {
        classCallCheck(this, Table);

        this.table = elem; // HTML Table Element
        this.parent = this.initialize();
        this.header = this._loadHeader();
    }

    createClass(Table, [{
        key: 'load',
        value: function load() {

            var r = new XMLHttpRequest();
            r.open('POST', this.table.getAttribute('data-target'), true);
            r.setRequestHeader('X-CSRF-TOKEN', '{{ csrf_token() }}');
            r.setRequestHeader('take', '10');
            r.setRequestHeader('skip', '20');
            r.setRequestHeader('search', 'Wiza');
            r.addEventListener('load', ajaxListener);
            r.onreadystatechange = function () {
                if (r.readyState != 4 || r.status != 200) return;
            };
            r.send();
        }
    }, {
        key: 'initialize',
        value: function initialize() {
            // Put wrapper around table.
            var wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            var table = this.table;
            table.parentElement.insertBefore(wrapper, table);
            wrapper.appendChild(table);
            return wrapper;
        }
    }, {
        key: '_loadHeader',
        value: function _loadHeader() {
            return new Header(this.table.tHead);
        }
    }]);
    return Table;
}();

// import { ajaxRequest } from './modules/ajaxRequest';

var elem = tables$1[0];
var table = new Table(elem);
table.load();

return tables$1;

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JpcHRzL2dsb2JhbHMuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL2hlYWRlci5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21vZHVsZXMvcGFnaW5hdG9yLmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9wb3B1bGF0ZVRhYmxlLmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9hamF4UmVxdWVzdC5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21vZHVsZXMvdGFibGUuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBsZXQgdGFibGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZWxvcXVlbnQtdGFibGUnKTtcblxuZXhwb3J0IGxldCBoZWFkZXJzID0gW10uc2xpY2VcbiAgICAuY2FsbCh0YWJsZXNbMF0udEhlYWQucXVlcnlTZWxlY3RvckFsbCgndGgnKSlcbiAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICByZXR1cm4gaGVhZGVyLmlubmVySFRNTDtcbiAgICB9KTtcblxuZXhwb3J0IGxldCB0b3RhbF9jb3VudCA9IHsgdmFsdWU6IDAsXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiBcdH1cbn07XG5cbmV4cG9ydCBsZXQgcm93cyA9IHsgXG5cdGNvbGxlY3Rpb246IG51bGwsXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNvbGxlY3Rpb24gPSB2YWx1ZTtcblx0fVxufTtcblxuZXhwb3J0IGxldCBjb25maWcgPSB7XG4gICAgdGFibGVSb3dzOiAxMCxcbiAgICBzZXRUYWJsZVJvd3M6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMudGFibGVSb3dzID0gdmFsdWU7IH1cbn0iLCJleHBvcnQgY2xhc3MgSGVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtKSB7XG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07ICAvLyBIVE1MIEVsZW1lbnRcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gdGhpcy5sb2FkKCk7XG4gICAgfVxuICBcbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gW10uc2xpY2VcbiAgICAgICAgICAuY2FsbCh0aGlzLmVsZW0ucXVlcnlTZWxlY3RvckFsbCgndGgnKSlcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXIuaW5uZXJIVE1MO1xuICAgICAgICAgIH0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyB0b3RhbF9jb3VudCwgY29uZmlnIH0gZnJvbSAnLi4vZ2xvYmFscyc7XG4vKipcbiAqIEZpcmVkIG9uIEFKQVggcmVzcG9uc2UgdG8gY29uc3RydWN0IHBhZ2luYXRlZCByZXN1bHRzLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUGFnaW5hdG9yKClcbntcbiAgICAvLyBjb25zb2xlLmxvZygnQ291bnQ6ICcgKyB0b3RhbF9jb3VudCk7XG59XG5cbmV4cG9ydCBjbGFzcyBQYWdpbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGVsZW0sIHRvdGFsKSB7XG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICB9XG4gIFxuICAgIGdldCBwYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1BhZ2VzKCk7XG4gICAgfVxuXG4gICAgY2FsY1BhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbCAvIGNvbmZpZy50YWJsZVJvd3M7XG4gICAgfVxuXG4gICAgYnVpbGRIVE1MKCkge1xuICAgICAgICBcbiAgICAgICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbm9kZS5jbGFzc05hbWUgPSAncGFnaW5hdG9yJztcbiAgICAgICAgLy8gd3JhcHBlci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSB0b3RhbF9jb3VudC52YWx1ZTtcbiAgICAgICAgdGhpcy5lbGVtLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyB0YWJsZXMsIHRvdGFsX2NvdW50IH0gZnJvbSAnLi4vZ2xvYmFscyc7XG5pbXBvcnQgeyBQYWdpbmF0b3IgfSBmcm9tICcuL3BhZ2luYXRvcic7XG4vKipcbiAqIEFKQVggTGlzdGVuZXIgdG8gYnVpbGQgdGFibGUgd2l0aCBkYXRhIHJldHVybmVkIFxuICogZnJvbSBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtICB7SnNvbn0gcGF5bG9hZCBhIHNlcnZlciByZXNwb25zZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wdWxhdGVUYWJsZShwYXlsb2FkKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKHRhYmxlcyk7XG4gICAgY29uc3QgZWxlbSA9IHRhYmxlc1swXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGJvZHknKVswXTtcbiAgICBwYXlsb2FkLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgcm93ID0gZWxlbS5pbnNlcnRSb3coLTEpO1xuICAgICAgICAvLyBJbnNlcnQgbmV3IGNlbGxzICg8dGQ+IGVsZW1lbnRzKSBhdCB0aGUgMXN0IGFuZCAybmQgcG9zaXRpb24gb2YgdGhlIFwibmV3XCIgPHRyPiBlbGVtZW50OlxuICAgICAgICB2YXIgY2VsbDEgPSByb3cuaW5zZXJ0Q2VsbCgwKTtcbiAgICAgICAgdmFyIGNlbGwyID0gcm93Lmluc2VydENlbGwoMSk7XG4gICAgICAgIHZhciBjZWxsMyA9IHJvdy5pbnNlcnRDZWxsKDIpO1xuICAgICAgICB2YXIgY2VsbDQgPSByb3cuaW5zZXJ0Q2VsbCgzKTtcblxuICAgICAgICAvLyBBZGQgc29tZSB0ZXh0IHRvIHRoZSBuZXcgY2VsbHM6XG4gICAgICAgIGNlbGwxLmlubmVySFRNTCA9IGRhdGEuaWQ7XG4gICAgICAgIGNlbGwyLmlubmVySFRNTCA9IGRhdGEuY29tcGFueS5uYW1lO1xuICAgICAgICBjZWxsMy5pbm5lckhUTUwgPSBkYXRhLm5hbWU7XG4gICAgICAgIGNlbGw0LmlubmVySFRNTCA9IGRhdGEucHJpY2U7XG4gICAgfSk7XG4gICAgLy8gY29uc29sZS5sb2cocGFnaW5hdG9yKTtcbiAgICB0b3RhbF9jb3VudC5zZXQocGF5bG9hZC5jb3VudCk7XG4gICAgbGV0IHBhZ2luYXRvciA9IG5ldyBQYWdpbmF0b3IoZWxlbSwgdG90YWxfY291bnQudmFsdWUpO1xuICAgIHBhZ2luYXRvci5idWlsZEhUTUwoKTtcbn0iLCJpbXBvcnQgeyB0YWJsZXMsIHJvd3MgfSBmcm9tICcuLi9nbG9iYWxzJztcbmltcG9ydCB7IHBvcHVsYXRlVGFibGUgfSBmcm9tICcuL3BvcHVsYXRlVGFibGUnO1xuLyoqXG4gKiBBSkFYIFJlcXVlc3QgdG8gc2VydmVyIHRvIGdldCBUYWJsZSBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWpheFJlcXVlc3QoKVxue1xuICAgIGxldCByID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgXG4gICAgci5vcGVuKCdQT1NUJywgdGFibGVzWzBdLmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKSwgdHJ1ZSk7XG4gICAgci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUNTUkYtVE9LRU4nLCAne3sgY3NyZl90b2tlbigpIH19Jyk7XG4gICAgci5zZXRSZXF1ZXN0SGVhZGVyKCd0YWtlJywgJzEwJyk7XG4gICAgci5zZXRSZXF1ZXN0SGVhZGVyKCdza2lwJywgJzIwJyk7XG4gICAgci5zZXRSZXF1ZXN0SGVhZGVyKCdzZWFyY2gnLCAnV2l6YScpO1xuICAgIHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGFqYXhMaXN0ZW5lcik7XG4gICAgci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLnJlYWR5U3RhdGUgIT0gNCB8fCByLnN0YXR1cyAhPSAyMDApIHJldHVybjsgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHIucmVzcG9uc2VUZXh0KTtcbiAgICB9O1xuICAgIHIuc2VuZCgndGFrZT0xJyk7XG59XG5cbi8qKlxuICogQ2FsbCBiYWNrIGZ1bmN0aW9uIGZpcmVkIG9uIEFKQVggcmVzdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWpheExpc3RlbmVyKClcbntcbiAgICByb3dzLnNldChKU09OLnBhcnNlKHRoaXMucmVzcG9uc2VUZXh0KSk7XG4gICAgcG9wdWxhdGVUYWJsZShyb3dzLmNvbGxlY3Rpb24pO1xufSIsIi8vIGltcG9ydCB7IFBhZ2luYXRvciB9IGZyb20gJy4vcGFnaW5hdG9yJztcbmltcG9ydCB7IEhlYWRlciB9IGZyb20gJy4vaGVhZGVyJztcbmltcG9ydCB7IGFqYXhMaXN0ZW5lciB9IGZyb20gJy4vYWpheFJlcXVlc3QnO1xuXG5leHBvcnQgY2xhc3MgVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW0pIHtcbiAgICAgICAgdGhpcy50YWJsZSA9IGVsZW07ICAvLyBIVE1MIFRhYmxlIEVsZW1lbnRcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSB0aGlzLl9sb2FkSGVhZGVyKCk7XG4gICAgfVxuICBcbiAgICBsb2FkKCkge1xuICAgICAgICBcbiAgICAgICAgbGV0IHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgci5vcGVuKCdQT1NUJywgdGhpcy50YWJsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JyksIHRydWUpO1xuICAgICAgICByLnNldFJlcXVlc3RIZWFkZXIoJ1gtQ1NSRi1UT0tFTicsICd7eyBjc3JmX3Rva2VuKCkgfX0nKTtcbiAgICAgICAgci5zZXRSZXF1ZXN0SGVhZGVyKCd0YWtlJywgJzEwJyk7XG4gICAgICAgIHIuc2V0UmVxdWVzdEhlYWRlcignc2tpcCcsICcyMCcpO1xuICAgICAgICByLnNldFJlcXVlc3RIZWFkZXIoJ3NlYXJjaCcsICdXaXphJyk7XG4gICAgICAgIHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGFqYXhMaXN0ZW5lcik7XG4gICAgICAgIHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHIucmVhZHlTdGF0ZSAhPSA0IHx8IHIuc3RhdHVzICE9IDIwMCkgcmV0dXJuOyBcbiAgICAgICAgfTtcbiAgICAgICAgci5zZW5kKCk7XG5cbiAgICB9XG4gICAgXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgLy8gUHV0IHdyYXBwZXIgYXJvdW5kIHRhYmxlLlxuICAgICAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTmFtZSA9ICd0YWJsZS13cmFwcGVyJztcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy50YWJsZTtcbiAgICAgICAgdGFibGUucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUod3JhcHBlciwgdGFibGUpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRhYmxlKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgX2xvYWRIZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGVhZGVyKHRoaXMudGFibGUudEhlYWQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyB0YWJsZXMgfSBmcm9tICcuL2dsb2JhbHMnO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL21vZHVsZXMvdGFibGUnO1xuLy8gaW1wb3J0IHsgYWpheFJlcXVlc3QgfSBmcm9tICcuL21vZHVsZXMvYWpheFJlcXVlc3QnO1xuXG5sZXQgZWxlbSA9IHRhYmxlc1swXTtcbmxldCB0YWJsZSA9IG5ldyBUYWJsZShlbGVtKTtcbnRhYmxlLmxvYWQoKTtcblxuZXhwb3J0IGRlZmF1bHQgdGFibGVzO1xuIl0sIm5hbWVzIjpbInRhYmxlcyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImhlYWRlcnMiLCJzbGljZSIsImNhbGwiLCJ0SGVhZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYXAiLCJoZWFkZXIiLCJpbm5lckhUTUwiLCJ0b3RhbF9jb3VudCIsInZhbHVlIiwicm93cyIsImNvbGxlY3Rpb24iLCJjb25maWciLCJ0YWJsZVJvd3MiLCJIZWFkZXIiLCJlbGVtIiwiY29sdW1ucyIsImxvYWQiLCJQYWdpbmF0b3IiLCJ0b3RhbCIsIm5vZGUiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiYXBwZW5kQ2hpbGQiLCJjYWxjUGFnZXMiLCJwb3B1bGF0ZVRhYmxlIiwicGF5bG9hZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiZGF0YSIsImZvckVhY2giLCJyb3ciLCJpbnNlcnRSb3ciLCJjZWxsMSIsImluc2VydENlbGwiLCJjZWxsMiIsImNlbGwzIiwiY2VsbDQiLCJpZCIsImNvbXBhbnkiLCJuYW1lIiwicHJpY2UiLCJzZXQiLCJjb3VudCIsInBhZ2luYXRvciIsImJ1aWxkSFRNTCIsImFqYXhMaXN0ZW5lciIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlVGV4dCIsIlRhYmxlIiwidGFibGUiLCJwYXJlbnQiLCJpbml0aWFsaXplIiwiX2xvYWRIZWFkZXIiLCJyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwiZ2V0QXR0cmlidXRlIiwic2V0UmVxdWVzdEhlYWRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwic2VuZCIsIndyYXBwZXIiLCJwYXJlbnRFbGVtZW50IiwiaW5zZXJ0QmVmb3JlIl0sIm1hcHBpbmdzIjoiOzs7QUFBTyxJQUFJQSxXQUFTQyxTQUFTQyxzQkFBVCxDQUFnQyxnQkFBaEMsQ0FBYjs7QUFFUCxBQUFPLElBQUlDLFVBQVUsR0FBR0MsS0FBSCxDQUNoQkMsSUFEZ0IsQ0FDWEwsU0FBTyxDQUFQLEVBQVVN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
