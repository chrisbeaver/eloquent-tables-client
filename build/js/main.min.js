(function () {
'use strict';

var tables = document.getElementsByClassName('eloquent-table');

var headers = [].slice.call(tables[0].tHead.querySelectorAll('th')).map(function (header) {
    return header.innerHTML;
});

var paginator = document.createElement('div');

var total_count = { value: 0,
    set: function set(value) {
        this.value = value;
    }
};

var rows = {
    collection: null,
    set: function set(value) {
        this.collection = value;
    }
};

var config = {
    tableRows: 10,
    setTableRows: function setTableRows(value) {
        this.tableRows = value;
    }
};

/**
 * Construct basic framework for creating a table.
 */
function initializeTable() {
    var wrapper = document.createElement('div');
    wrapper.className = 'table-wrapper';
    var table = tables[0];

    document.body.insertBefore(wrapper, table);
    wrapper.appendChild(table);

    // paginator = document.createElement("div");
    paginator.className = 'paginator';
    wrapper.appendChild(paginator);
}

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

/**
 * Fired on AJAX response to construct paginated results.
 *
 */
function buildPaginator() {
    // console.log('Count: ' + total_count);
    paginator.innerHTML = total_count.value;
    var totalPages = total_count.value / config.tableRows;
    alert(totalPages);
}

var Paginator = function () {
    function Paginator(total) {
        classCallCheck(this, Paginator);

        this.total = total;
    }

    createClass(Paginator, [{
        key: 'calcPages',
        value: function calcPages() {
            return this.total / config.tableRows;
        }
    }, {
        key: 'pages',
        get: function get() {
            return this.calcPages();
        }
    }]);
    return Paginator;
}();

/**
 * AJAX Listener to build table with data returned 
 * from server.
 *
 * @param  {Json} payload a server response
 */
function populateTable(payload) {
    // console.log(tables);
    payload.data.forEach(function (data) {

        var row = tables[0].getElementsByTagName('tbody')[0].insertRow(-1);
        // Insert new cells (<td> elements) at the 1st and 2nd position of the "new" <tr> element:
        var cell1 = row.insertCell(0);
        var cell2 = row.insertCell(1);
        var cell3 = row.insertCell(2);
        var cell4 = row.insertCell(3);

        // Add some text to the new cells:
        cell1.innerHTML = data.id;
        cell2.innerHTML = data.company.name;
        cell3.innerHTML = data.name;
        cell4.innerHTML = data.price;
    });
    // console.log(paginator);
    total_count.set(payload.count);
    buildPaginator();
    var paginatorObject = new Paginator(total_count.value);
    console.log(paginatorObject);
}

/**
 * AJAX Request to server to get Table data.
 */
function ajaxRequest() {
    var r = new XMLHttpRequest();

    r.open('POST', tables[0].getAttribute('data-target'), true);
    r.setRequestHeader('X-CSRF-TOKEN', '{{ csrf_token() }}');
    r.setRequestHeader('take', '10');
    r.setRequestHeader('skip', '20');
    r.setRequestHeader('search', 'Wiza');
    r.addEventListener('load', ajaxListener);
    r.onreadystatechange = function () {
        if (r.readyState != 4 || r.status != 200) return;
        // console.log(r.responseText);
    };
    r.send('take=1');
}

/**
 * Call back function fired on AJAX result.
 */
function ajaxListener() {
    // console.log(JSON.parse(this.responseText));
    rows.set(JSON.parse(this.responseText));
    // console.log(rows.collection);
    populateTable(rows.collection);
}

initializeTable();
ajaxRequest();

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JpcHRzL2dsb2JhbHMuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL2luaXRpYWxpemVUYWJsZS5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21vZHVsZXMvcGFnaW5hdG9yLmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9wb3B1bGF0ZVRhYmxlLmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9hamF4UmVxdWVzdC5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGxldCB0YWJsZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdlbG9xdWVudC10YWJsZScpO1xuXG5leHBvcnQgbGV0IGhlYWRlcnMgPSBbXS5zbGljZVxuICAgIC5jYWxsKHRhYmxlc1swXS50SGVhZC5xdWVyeVNlbGVjdG9yQWxsKCd0aCcpKVxuICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXIuaW5uZXJIVE1MO1xuICAgIH0pO1xuXG5leHBvcnQgbGV0IHBhZ2luYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5leHBvcnQgbGV0IHRvdGFsX2NvdW50ID0geyB2YWx1ZTogMCxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuIFx0fVxufTtcblxuZXhwb3J0IGxldCByb3dzID0geyBcblx0Y29sbGVjdGlvbjogbnVsbCxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuY29sbGVjdGlvbiA9IHZhbHVlO1xuXHR9XG59O1xuXG5leHBvcnQgbGV0IGNvbmZpZyA9IHtcbiAgICB0YWJsZVJvd3M6IDEwLFxuICAgIHNldFRhYmxlUm93czogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy50YWJsZVJvd3MgPSB2YWx1ZTsgfVxufSIsImltcG9ydCB7IHRhYmxlcywgcGFnaW5hdG9yIH0gZnJvbSAnLi4vZ2xvYmFscyc7XG4vKipcbiAqIENvbnN0cnVjdCBiYXNpYyBmcmFtZXdvcmsgZm9yIGNyZWF0aW5nIGEgdGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplVGFibGUoKVxue1xuICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5jbGFzc05hbWUgPSAndGFibGUtd3JhcHBlcic7XG4gICAgbGV0IHRhYmxlID0gdGFibGVzWzBdO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHRhYmxlKTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRhYmxlKTtcblxuICAgIC8vIHBhZ2luYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcGFnaW5hdG9yLmNsYXNzTmFtZSA9ICdwYWdpbmF0b3InO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocGFnaW5hdG9yKTtcbn0iLCJpbXBvcnQgeyBwYWdpbmF0b3IsIHRvdGFsX2NvdW50LCBjb25maWcgfSBmcm9tICcuLi9nbG9iYWxzJztcbi8qKlxuICogRmlyZWQgb24gQUpBWCByZXNwb25zZSB0byBjb25zdHJ1Y3QgcGFnaW5hdGVkIHJlc3VsdHMuXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQYWdpbmF0b3IoKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKCdDb3VudDogJyArIHRvdGFsX2NvdW50KTtcbiAgICBwYWdpbmF0b3IuaW5uZXJIVE1MID0gdG90YWxfY291bnQudmFsdWU7XG4gICAgbGV0IHRvdGFsUGFnZXMgPSB0b3RhbF9jb3VudC52YWx1ZSAvIGNvbmZpZy50YWJsZVJvd3M7XG4gICAgYWxlcnQodG90YWxQYWdlcyk7XG59XG5cbmV4cG9ydCBjbGFzcyBQYWdpbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHRvdGFsKSB7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICB9XG4gIFxuICAgIGdldCBwYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1BhZ2VzKCk7XG4gICAgfVxuXG4gICAgY2FsY1BhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbCAvIGNvbmZpZy50YWJsZVJvd3M7XG4gICAgfVxufSIsImltcG9ydCB7IHRhYmxlcywgdG90YWxfY291bnQgfSBmcm9tICcuLi9nbG9iYWxzJztcbmltcG9ydCB7IGJ1aWxkUGFnaW5hdG9yLCBQYWdpbmF0b3IgfSBmcm9tICcuL3BhZ2luYXRvcic7XG4vKipcbiAqIEFKQVggTGlzdGVuZXIgdG8gYnVpbGQgdGFibGUgd2l0aCBkYXRhIHJldHVybmVkIFxuICogZnJvbSBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtICB7SnNvbn0gcGF5bG9hZCBhIHNlcnZlciByZXNwb25zZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wdWxhdGVUYWJsZShwYXlsb2FkKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKHRhYmxlcyk7XG4gICAgcGF5bG9hZC5kYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBcbiAgICAgICAgdmFyIHJvdyA9IHRhYmxlc1swXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGJvZHknKVswXS5pbnNlcnRSb3coLTEpO1xuICAgICAgICAvLyBJbnNlcnQgbmV3IGNlbGxzICg8dGQ+IGVsZW1lbnRzKSBhdCB0aGUgMXN0IGFuZCAybmQgcG9zaXRpb24gb2YgdGhlIFwibmV3XCIgPHRyPiBlbGVtZW50OlxuICAgICAgICB2YXIgY2VsbDEgPSByb3cuaW5zZXJ0Q2VsbCgwKTtcbiAgICAgICAgdmFyIGNlbGwyID0gcm93Lmluc2VydENlbGwoMSk7XG4gICAgICAgIHZhciBjZWxsMyA9IHJvdy5pbnNlcnRDZWxsKDIpO1xuICAgICAgICB2YXIgY2VsbDQgPSByb3cuaW5zZXJ0Q2VsbCgzKTtcblxuICAgICAgICAvLyBBZGQgc29tZSB0ZXh0IHRvIHRoZSBuZXcgY2VsbHM6XG4gICAgICAgIGNlbGwxLmlubmVySFRNTCA9IGRhdGEuaWQ7XG4gICAgICAgIGNlbGwyLmlubmVySFRNTCA9IGRhdGEuY29tcGFueS5uYW1lO1xuICAgICAgICBjZWxsMy5pbm5lckhUTUwgPSBkYXRhLm5hbWU7XG4gICAgICAgIGNlbGw0LmlubmVySFRNTCA9IGRhdGEucHJpY2U7XG4gICAgfSk7XG4gICAgLy8gY29uc29sZS5sb2cocGFnaW5hdG9yKTtcbiAgICB0b3RhbF9jb3VudC5zZXQocGF5bG9hZC5jb3VudCk7XG4gICAgYnVpbGRQYWdpbmF0b3IoKTtcbiAgICBsZXQgcGFnaW5hdG9yT2JqZWN0ID0gbmV3IFBhZ2luYXRvcih0b3RhbF9jb3VudC52YWx1ZSk7XG4gICAgY29uc29sZS5sb2cocGFnaW5hdG9yT2JqZWN0KTtcbn0iLCJpbXBvcnQgeyB0YWJsZXMsIHJvd3MgfSBmcm9tICcuLi9nbG9iYWxzJztcbmltcG9ydCB7IHBvcHVsYXRlVGFibGUgfSBmcm9tICcuL3BvcHVsYXRlVGFibGUnXG4vKipcbiAqIEFKQVggUmVxdWVzdCB0byBzZXJ2ZXIgdG8gZ2V0IFRhYmxlIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhamF4UmVxdWVzdCgpXG57XG4gICAgbGV0IHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBcbiAgICByLm9wZW4oJ1BPU1QnLCB0YWJsZXNbMF0uZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpLCB0cnVlKTtcbiAgICByLnNldFJlcXVlc3RIZWFkZXIoJ1gtQ1NSRi1UT0tFTicsICd7eyBjc3JmX3Rva2VuKCkgfX0nKTtcbiAgICByLnNldFJlcXVlc3RIZWFkZXIoJ3Rha2UnLCAnMTAnKTtcbiAgICByLnNldFJlcXVlc3RIZWFkZXIoJ3NraXAnLCAnMjAnKTtcbiAgICByLnNldFJlcXVlc3RIZWFkZXIoJ3NlYXJjaCcsICdXaXphJyk7XG4gICAgci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgYWpheExpc3RlbmVyKTtcbiAgICByLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHIucmVhZHlTdGF0ZSAhPSA0IHx8IHIuc3RhdHVzICE9IDIwMCkgcmV0dXJuOyBcbiAgICAgICAgLy8gY29uc29sZS5sb2coci5yZXNwb25zZVRleHQpO1xuICAgIH07XG4gICAgci5zZW5kKCd0YWtlPTEnKTtcbn1cblxuLyoqXG4gKiBDYWxsIGJhY2sgZnVuY3Rpb24gZmlyZWQgb24gQUpBWCByZXN1bHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhamF4TGlzdGVuZXIoKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpKTtcbiAgICByb3dzLnNldChKU09OLnBhcnNlKHRoaXMucmVzcG9uc2VUZXh0KSk7XG4gICAgLy8gY29uc29sZS5sb2cocm93cy5jb2xsZWN0aW9uKTtcbiAgICBwb3B1bGF0ZVRhYmxlKHJvd3MuY29sbGVjdGlvbik7XG59IiwiaW1wb3J0IHsgaW5pdGlhbGl6ZVRhYmxlIH0gZnJvbSAnLi9tb2R1bGVzL2luaXRpYWxpemVUYWJsZSc7XG5pbXBvcnQgeyBhamF4UmVxdWVzdCB9IGZyb20gJy4vbW9kdWxlcy9hamF4UmVxdWVzdCc7XG5cbmluaXRpYWxpemVUYWJsZSgpO1xuYWpheFJlcXVlc3QoKTtcbiJdLCJuYW1lcyI6WyJ0YWJsZXMiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJoZWFkZXJzIiwic2xpY2UiLCJjYWxsIiwidEhlYWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwibWFwIiwiaGVhZGVyIiwiaW5uZXJIVE1MIiwicGFnaW5hdG9yIiwiY3JlYXRlRWxlbWVudCIsInRvdGFsX2NvdW50IiwidmFsdWUiLCJyb3dzIiwiY29sbGVjdGlvbiIsImNvbmZpZyIsInRhYmxlUm93cyIsImluaXRpYWxpemVUYWJsZSIsIndyYXBwZXIiLCJjbGFzc05hbWUiLCJ0YWJsZSIsImJvZHkiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsImJ1aWxkUGFnaW5hdG9yIiwidG90YWxQYWdlcyIsIlBhZ2luYXRvciIsInRvdGFsIiwiY2FsY1BhZ2VzIiwicG9wdWxhdGVUYWJsZSIsInBheWxvYWQiLCJkYXRhIiwiZm9yRWFjaCIsInJvdyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5zZXJ0Um93IiwiY2VsbDEiLCJpbnNlcnRDZWxsIiwiY2VsbDIiLCJjZWxsMyIsImNlbGw0IiwiaWQiLCJjb21wYW55IiwibmFtZSIsInByaWNlIiwic2V0IiwiY291bnQiLCJwYWdpbmF0b3JPYmplY3QiLCJsb2ciLCJhamF4UmVxdWVzdCIsInIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJnZXRBdHRyaWJ1dGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFqYXhMaXN0ZW5lciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJzZW5kIiwiSlNPTiIsInBhcnNlIiwicmVzcG9uc2VUZXh0Il0sIm1hcHBpbmdzIjoiOzs7QUFBTyxJQUFJQSxTQUFTQyxTQUFTQyxzQkFBVCxDQUFnQyxnQkFBaEMsQ0FBYjs7QUFFUCxBQUFPLElBQUlDLFVBQVUsR0FBR0MsS0FBSCxDQUNoQkMsSUFEZ0IsQ0FDWEwsT0FBTyxDQUFQLEVBQVVNLEtBQVYsQ0FBZ0JDLGdCQUFoQixDQUFpQyxJQUFqQyxDQURXLEVBRWhCQyxHQUZnQixDQUVaLFVBQVNDLE1BQVQsRUFBaUI7V0FDWEEsT0FBT0MsU0FBZDtDQUhhLENBQWQ7O0FBTVAsQUFBTyxJQUFJQyxZQUFZVixTQUFTVyxhQUFULENBQXVCLEtBQXZCLENBQWhCOztBQUVQLEFBQU8sSUFBSUMsY0FBYyxFQUFFQyxPQUFPLENBQVQ7U0FDaEIsYUFBU0EsS0FBVCxFQUFnQjthQUNsQkEsS0FBTCxHQUFhQSxLQUFiOztDQUZLOztBQU1QLEFBQU8sSUFBSUMsT0FBTztnQkFDTCxJQURLO1NBRVosYUFBU0QsS0FBVCxFQUFnQjthQUNmRSxV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
